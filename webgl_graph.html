<!doctype html>
<!-- 
     Simple oscilloscope trace plot using WebGL
     Copyright (c) Jeremy P Bentham 2021. See http://iosoft.blog for details
     Modified for 8-channel EEG example
     
     *** MODIFIED TO USE WEBSOCKET (from java_rpi.html) ***
     *** MODIFIED TO ADD START/STOP BUTTONS & REMOVE ECHO ***
     *** MODIFIED to handle 8-channel synchronized (scrolling) data ***
     *** MODIFIED for EEG: Added labels, light theme, no grid, fixed amplitude ***
     *** MODIFIED for 9 Channels: 8 EEG (Grey) + 1 Event (Red) ***
-->
<html>
   <body onload=start_graph()>
      <!-- Canvases and labels will be added here dynamically -->
      <div id="canvas-container"></div>
      
      <!-- UI controls -->
      <div class="controls-bar">
         <input type="button" value="Connect" onClick="connect();">
         <input type="button" value="Disconnect" onClick="disconnect();">
         <input type="button" value="Start" onClick="send_start();">
         <input type="button" value="Stop" onClick="send_stop();">
         <select id="sel_nchans" onchange="sel_nchans()"></select>
      </div>
      <pre id="status" style="font-size: 14px; margin: 8px"></pre>
      
      <style>
        body { 
            font-family: sans-serif; 
            background-color: #f0f0f0; /* Lighter background */
            color: #333; /* Darker text */
        }
        .controls-bar {
            margin: 5px;
        }
        .channel-wrapper {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
            width: 98%;
        }
        .channel-label {
            font-size: 14px;
            font-weight: bold;
            color: #555;
            width: 50px; /* Fixed width for alignment */
            text-align: right;
            margin-right: 10px;
        }
        canvas { 
            background-color: #ffffff; /* White graph background */
            border: 1px solid #ccc;
            flex-grow: 1; /* Canvas takes remaining width */
        }
        button, select, input[type=button] { 
            font-size: 16px; 
            margin: 5px; 
        }
      </style>

      <script>
        // --- CONSTANTES ---
        const WEBGL2 = true;
        const NORM_XMIN=-1.0, NORM_XMAX=1.0, NORM_YMIN=-1.0, NORM_YMAX=1.0;
        const XMARGIN=20, YMARGIN=90, MIN_CHANS=1, MAX_CHANS=16;
        
        // *** NEW: Total channels is now 9 ***
        const NCHANS = 9; 
        const MAX_SAMPLES = 1000; 

        // Fixed amplitude range for EEG (e.g., -100µV to +100µV)
        const EEG_Y_RANGE_MV = 100.0; 
        
        // --- WebSocket Client Vars ---
        const portnum = 3001;
        var host, server, websock, connected = false;

        // --- Variables Globales (WebGL) ---
        var gl; 
        var canvas; 
        var clear_colour = [1.0, 1.0, 1.0, 1.0]; // White canvas background
        
        // *** NEW: Updated trace colors ***
        var trace_colours = [
            [0.9, 0.9, 0.9, 1], // 0: Placeholder (not used)
            colr(0x333333),     // 1: Dark Grey (for all 8 EEG channels)
            colr(0xC00000),     // 2: Unused
            colr(0x0000C0),     // 3: Unused
            colr(0xB0B000),     // 4: Unused
            colr(0x00A0A0),     // 5: Unused
            colr(0xC000C0),     // 6: Unused
            colr(0xD07000),     // 7: Unused
            colr(0x333333),     // 8: Unused
            colr(0xFF0000),     // 9: Bright Red (for Event channel)
            // ... (remaining colors)
            colr(0x969696), colr(0xffffcc), colr(0x000000), 
            colr(0x800000), colr(0xff0000), colr(0xff9900), 
            colr(0xffff00), colr(0x00ff00)];

        var program, num_chans = NCHANS;
        
        // --- Data Storage ---
        var trace_vertices = []; 
        var channel_data_buffers = []; 

        var all_canvases = []; 
        var all_gl_contexts = []; 
        var frag_code, vert_code; 

         // --- Shaders (Sin cambios del original) ---
         if (WEBGL2)
            frag_code = `#version 300 es
                precision mediump float;
                in vec4 v_colour;
                out vec4 o_colour;
                void main() {
                    o_colour = v_colour;
                }`;
        else
            frag_code = `
                precision mediump float;
                varying vec4 v_colour;
                void main(void) {
                    gl_FragColor = v_colour;
                }`;

         if (WEBGL2)
            vert_code = `#version 300 es
                in vec3 a_coords;
                out vec4 v_colour;
                `;
        else
            vert_code = `
                attribute vec3 a_coords;
                varying vec4 v_colour;
                `;
        vert_code +=
           `#define MAX_CHANS ${MAX_CHANS}
            uniform vec4 u_colours[MAX_CHANS];
            void main(void) {
               int zint = int(a_coords.z);
               gl_Position = vec4(a_coords.x, a_coords.y, 0, 1);
               v_colour = u_colours[zint];
            }`;

        // --- Funciones de Inicialización ---

        function start_graph() {
            var container = elem("canvas-container");
            
            // 1. Crear 9 canvases, each with a label
            for (var i=0; i < NCHANS; i++) {
                var wrapper = document.createElement('div');
                wrapper.className = 'channel-wrapper';

                // *** NEW: Label logic for 9 channels ***
                var label = document.createElement('span');
                label.className = 'channel-label';
                if (i < 8) {
                    label.innerText = 'CH' + (i + 1); // CH1 - CH8
                } else {
                    label.innerText = 'Events'; // 9th channel
                }
                wrapper.appendChild(label);

                var new_canvas = document.createElement('canvas');
                new_canvas.id = "graph_canvas_" + i;
                new_canvas.width = 1000;
                new_canvas.height = 100; 
                wrapper.appendChild(new_canvas);

                container.appendChild(wrapper);
                all_canvases.push(new_canvas);
            }
            canvas = all_canvases[0];
            
            // 2. Configurar selector de canales
            var sel = document.getElementById("sel_nchans");
            for (var n=MIN_CHANS; n<=MAX_CHANS; n++)
                sel.options.add(new Option(n+" channel"+(n>1?"s":""), value=n));
            sel.selectedIndex = NCHANS - 1; // Select "9 channels"
            
            // 3. Inicializar WebGL para cada canvas
            try {
                for (var i=0; i < NCHANS; i++) {
                    init_graph(all_canvases[i]);
                }
            } catch (e) {
                console.error("Error initializing WebGL: " + e);
                disp_status("Error: " + e);
            }
            
            // 4. Configurar programa WebGL (colores)
            gl = all_gl_contexts[0];
            program = gl.program;
            gl.useProgram(program);
            
            var clrs = gl.getUniformLocation(program, 'u_colours');
            gl.uniform4fv(clrs, new Float32Array(trace_colours.flat()));
            
            for (var i=0; i < NCHANS; i++) {
                // Initialize buffers for each channel
                trace_vertices.push([]);
                channel_data_buffers.push([]);
            }
            
            // 5. Configurar eventos y primer dibujado
            window.addEventListener("resize", resize_canvas);
            resize_canvas();
            
            // 6. Inicializar WebSocket
            host = location.host ? String(location.host) : "localhost";
            host = host.replace("127.0.0.1", "localhost");
            server = host.replace(/:\d*\b/, ":" + portnum);
            disp_status("Host " + host + ". Ready to connect.");
            
            redraw_graph();
        }

        // Inicializa un contexto WebGL y shaders para un canvas específico
        function init_graph(canvas_elem) {
            var local_gl = canvas_elem.getContext(WEBGL2 ? 'webgl2' : 'experimental-webgl');
            if (!local_gl) { throw "WebGL not supported"; }
            
            var vertex_buffer = local_gl.createBuffer();
            local_gl.bindBuffer(local_gl.ARRAY_BUFFER, vertex_buffer);
            var frag_shader = compile_shader(local_gl, local_gl.FRAGMENT_SHADER, frag_code);
            var vert_shader = compile_shader(local_gl, local_gl.VERTEX_SHADER, vert_code);
            var local_program = local_gl.createProgram();
            local_gl.attachShader(local_program, vert_shader);
            local_gl.attachShader(local_program, frag_shader);
            local_gl.linkProgram(local_program);
            local_gl.useProgram(local_program);
            local_gl.bindBuffer(local_gl.ARRAY_BUFFER, vertex_buffer);
            
            var coord = local_gl.getAttribLocation(local_program, "a_coords");
            local_gl.vertexAttribPointer(coord, 3, local_gl.FLOAT, false, 0, 0);
            local_gl.enableVertexAttribArray(coord);

            local_gl.program = local_program; 
            all_gl_contexts.push(local_gl);
        }

        // Compila un shader
        function compile_shader(gl_ctx, typ, source) {
            var s = gl_ctx.createShader(typ);
            gl_ctx.shaderSource(s, source);
            gl_ctx.compileShader(s);
            if (!gl_ctx.getShaderParameter(s, gl_ctx.COMPILE_STATUS))
                throw "Could not compile " +
                      (typ==gl_ctx.VERTEX_SHADER ? "vertex" : "fragment") +
                      " shader:\n\n"+gl_ctx.getShaderInfoLog(s);
            return(s);
        }

        // --- WebSocket Functions ---

        function connect() {
            var url = "ws://" + server + ":3001/";
            disp_status("Opening websocket " + url + "\n");
            websock = new WebSocket(url);
            websock.onopen    = function(evt) {sock_open(evt)};
            websock.onclose   = function(evt) {sock_close(evt)};
            websock.onmessage = function(evt) {sock_message(evt)};
            websock.onerror   = function(evt) {sock_error(evt)};
            connected = true;
        }
        
        function disconnect() {
            connected = false;
            if (websock) websock.close();
        }

        function sock_message(evt) {
            var data = evt.data;
            var vals = csv_decode(data); 
            
            // *** NEW: Expects 9 data points ***
            if (vals.length === num_chans) { 
                for (var chan = 0; chan < num_chans; chan++) {
                    let buffer = channel_data_buffers[chan];
                    buffer.push(vals[chan]);
                    if (buffer.length > MAX_SAMPLES) {
                        buffer.shift();
                    }
                }
                
                let bufferLen = channel_data_buffers[0].length;
                disp_status(`${vals.length} points rcvd. Buffer: ${bufferLen}/${MAX_SAMPLES}`);

                draw_traces();
                redraw_data();
                redraw_graph();

            } else if (vals.length > 0) {
                disp_status(`Error: Received ${vals.length} data points, expected ${num_chans}.`);
            } else {
                disp_status("No data received");
            }
        }

        function sock_open(evt) {
            disp_status("Connected\n");
        }
        function sock_close(evt) {
            disp_status("\nDisconnected\n");
        }
        function sock_error(evt) {
            disp_status("Socket error\n");
            if (websock) websock.close();
        }

        // --- Start/Stop Functions ---
        function send_start() {
            // *** NEW: Send 'start_9' ***
            var msg = 'start_9';
            if (connected && websock) {
                websock.send(msg);
                console.log("Sent: " + msg);
                disp_status("Sent: " + msg);
            } else {
                var err = "Not connected. Cannot send 'start_9'.";
                console.log(err);
                disp_status(err);
            }
        }

        function send_stop() {
            var msg = 'stop';
            if (connected && websock) {
                websock.send(msg);
                console.log("Sent: " + msg);
                disp_status("Sent: " + msg);
            } else {
                var err = "Not connected. Cannot send 'stop'.";
                console.log(err);
                disp_status(err);
            }
        }

        // --- Funciones de Dibujado (WebGL) ---

        function set_point(vts, x, y, z) { vts.push(x, y, z); }
        function draw_line(vts, x1, y1, x2, y2, z) { vts.push(x1, y1, z, x2, y2, z); }

        /**
         * *** MODIFIED: draw_traces ***
         * Uses fixed amplitude for EEG (ch 0-7) and a
         * separate fixed amplitude for Events (ch 8).
         * Sets zval for color: 1=EEG (Grey), 9=Event (Red)
         */
        function draw_traces() {
            var x, y; 

            for (var chan = 0; chan < num_chans; chan++) {
                trace_vertices[chan] = []; // Clear old vertices
                let vts = trace_vertices[chan];
                let buffer = channel_data_buffers[chan];
                let np = buffer.length; 
                
                let zval;
                let y_mid;
                let y_range_half;

                if (chan < 8) { // This is an EEG channel (0-7)
                    zval = 1; // Use color index 1 (Dark Grey)
                    y_mid = 0.0;
                    y_range_half = EEG_Y_RANGE_MV; // e.g., 100.0
                } else { // This is the Event channel (8)
                    zval = 9; // Use color index 9 (Red)
                    
                    // Assuming event data is 0 or 1.
                    // This centers the line: (0 - 0.5) / 0.5 = -1 (bottom)
                    //                           (1 - 0.5) / 0.5 = +1 (top)
                    y_mid = 0.5;
                    y_range_half = 0.5; 
                }
                
                if (np < 2) continue; // Not enough points to draw a line
                
                for (var n = 0; n < np; n++) {
                    if (n > 1) {
                        set_point(vts, x, y, zval); // Add PREVIOUS point
                    }
                    
                    x = NORM_XMIN + (NORM_XMAX - NORM_XMIN) * n / (MAX_SAMPLES - 1);
                    y = (buffer[n] - y_mid) / y_range_half;
                    
                    // Clamp values
                    if (y > 1.0) y = 1.0;
                    if (y < -1.0) y = -1.0;
                    
                    set_point(vts, x, y, zval); // Add CURRENT point
                }
            }
        }

        // Carga los datos de la grilla y la traza en el buffer de la GPU
        function redraw_data() {
            for (var i=0; i < NCHANS; i++) {
                var gl_ctx = all_gl_contexts[i];
                gl_ctx.useProgram(gl_ctx.program);
                
                var graph_vertices = [];
                if (trace_vertices[i]) {
                    graph_vertices.push(...trace_vertices[i]); 
                }
                
                gl_ctx.bufferData(gl_ctx.ARRAY_BUFFER, new Float32Array(graph_vertices), gl_ctx.STATIC_DRAW);
            }
        }

        // Dibuja la escena en todos los canvases
        function redraw_graph() {
            for (var i=0; i < NCHANS; i++) {
                var gl_ctx = all_gl_contexts[i];
                var canvas_elem = all_canvases[i];
                
                gl_ctx.viewport(0, 0, canvas_elem.width, canvas_elem.height);
                gl_ctx.clearColor(...clear_colour);
                gl_ctx.clear(gl_ctx.COLOR_BUFFER_BIT);
                
                var num_trace_verts = trace_vertices[i] ? trace_vertices[i].length / 3 : 0;
                
                if (num_trace_verts > 0)
                    gl_ctx.drawArrays(gl_ctx.LINES, 0, num_trace_verts);
            }
        }
        
        // --- Funciones Utilitarias ---
        function disp_status(s) { 
            var status_elem = elem('status');
            status_elem.innerHTML = s.trim();
            if (status_elem.innerHTML.length > 1000) {
                 status_elem.innerHTML = s.trim();
            }
        }

        function resize_canvas() {
            var w = canvas.clientWidth; 
            
            var h = (window.innerHeight - YMARGIN - (NCHANS * 10)) / NCHANS;
            if (h < 40) h = 40; // Min height
            
            for (var i=0; i < NCHANS; i++) {
                all_canvases[i].width  = w;
                all_canvases[i].height = h;
                all_canvases[i].style.height = h + 'px';
            }
            redraw_graph();
        }

        // Selector de canales
        function sel_nchans() {
            var sel = document.getElementById("sel_nchans");
            var new_n = sel.options[sel.selectedIndex].value;
            if (new_n != num_chans) {
                // *** NEW: Updated message for 9 channels ***
                var msg = "This demo is locked to " + NCHANS + " channels.";
                console.log(msg);
                disp_status(msg);
                sel.selectedIndex = NCHANS - 1;
            }
        }

        // Decodificador de CSV
        function csv_decode(s) {
            data = s.trim().split(',');
            if (data.length > 0 && data[data.length-1] == "") { data.pop(); } 
            if (data.length === 1 && data[0] === "") { return []; }
            return data.map(x => parseFloat(x));
        }

        // Convertidor de color Hex a RGB normalizado
        function colr(x) {
            return([(x>>16&255)/255.0, (x>>8&255)/255.0, (x&255)/255.0, 1.0]);
        }

        // Acceso rápido a elementos
        function elem(id) { return document.getElementById(id); }

      </script>
   </body>
</html>